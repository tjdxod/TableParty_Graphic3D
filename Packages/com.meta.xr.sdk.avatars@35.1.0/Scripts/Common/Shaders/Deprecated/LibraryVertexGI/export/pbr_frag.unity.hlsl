// Generated by AvatarShaderLibrary 
#ifdef ENABLE_enableEnvironmentMap
  static const bool enableEnvironmentMap = true;
#else
  static const bool enableEnvironmentMap = false;
#endif

static const bool hasBaseColorMap = true;
static const bool hasMetallicRoughnessMap = true;
static const int lightSampleCount = 5;
static const float lightSize = 0.5f;
static const float roughnessCutOff = 0.20000000298023223876953125f;
static const float lowerBound = 0.0500000007450580596923828125f;
static const float reduceRoughnessByValue = 0.100000001490116119384765625f;
static const float reducedLightSizeMultiplier = 10.0f;
static const float multiSampleBrightnessMultiplier = 0.449999988079071044921875f;
static const float singleSampleBrightnessMultiplier = 0.07500000298023223876953125f;
static const float SSSIBLMultiplier = 0.5f;
static const float increaseOcclusion = 0.4000000059604644775390625f;
static const float SSSWrapAngle = -0.64999997615814208984375f;
static const float diffuseWrapAngle = -0.1500000059604644775390625f;
static const float f0 = 0.039999999105930328369140625f;
static const float f90 = 1.0f;

struct avatar_Light
{
    float3 direction;
    float range;
    float3 color;
    float intensity;
    float3 position;
    float innerConeCos;
    float outerConeCos;
    float shadowTerm;
    int type;
    int eyeGlint;
};

struct avatar_FragOptions
{
    bool hasBaseColorMap;
    bool hasMetallicRoughnessMap;
    bool useIBLRotation;
    bool enableNormalMapping;
    bool enableAlphaToCoverage;
    bool enableEnvironmentMap;
    bool enableRimLight;
    bool enablePreviewColorRamp;
    bool enableDebugRender;
    bool enableSkin;
    bool enableEyeGlint;
    bool enableHeadHair;
    bool enableFacialHair;
    bool enableAnyHair;
    bool enableShadows;
    bool enableLightMask;
};

struct avatar_LightLookParams
{
    int lightSampleCount;
    float lightSize;
    float roughnessCutOff;
    float lowerBound;
    float reduceRoughnessByValue;
    float reducedLightSizeMultiplier;
    float multiSampleBrightnessMultiplier;
    float singleSampleBrightnessMultiplier;
};

struct avatar_SkinLookParams
{
    float SSSIBLMultiplier;
    float increaseOcclusion;
};

struct avatar_SkinMaterial
{
    float3 subsurface_color;
    float3 skin_ORM_factor;
};

struct avatar_HairMaterial
{
    float3 subsurface_color;
    float scatter_intensity;
    float3 specular_color_factor;
    float specular_shift_intensity;
    float specular_white_intensity;
    float specular_white_roughness;
    float specular_color_intensity;
    float specular_color_offset;
    float specular_color_roughness;
    float anisotropic_intensity;
    float diffused_intensity;
    float normal_intensity;
    float specular_glint;
    float ao_intensity;
    float flow_sample;
    float flow_angle;
    float shift;
    float blend;
    float aniso_blend;
};

struct avatar_RimLightMaterial
{
    float intensity;
    float bias;
    float3 color;
    float transition;
    float start;
    float end;
};

struct avatar_Material
{
    float3 base_color;
    float alpha;
    float exposure;
    float metallic;
    float occlusion;
    float roughness;
    float thickness;
    float ambient_diffuse_factor;
    float ambient_specular_factor;
    float eye_glint_factor;
    float eye_glint_color_factor;
    avatar_SkinMaterial skin_material;
    avatar_HairMaterial hair_material;
    avatar_RimLightMaterial rim_light_material;
    float ramp_selector;
    int color_selector_lod;
    float SSSWrapAngle;
    float diffuseWrapAngle;
    float f0;
    float f90;
};

struct avatar_Matrices
{
    float4x4 objectToWorld;
    float3x3 worldToObject;
    float4x4 viewProjection;
    float3x3 environmentRotation;
};

struct avatar_TangentSpace
{
    float3 normal;
    float3 tangent;
    float3 bitangent;
};

struct avatar_Geometry
{
    float3 camera;
    float3 positionInClipSpace;
    float3 positionInWorldSpace;
    float3 normal;
    float3 normalMap;
    avatar_TangentSpace tangentSpace;
    float2 texcoord_0;
    float2 texcoord_1;
    float4 color;
    float4 ormt;
    float normalScale;
    bool invertNormalSpaceEyes;
    float3 worldViewDir;
    float lod;
};

struct avatar_AmbientLighting
{
    float3 diffuse;
    float3 specular;
};

struct avatar_FragmentInput
{
    avatar_FragOptions options;
    avatar_Matrices matrices;
    avatar_Geometry geometry;
    avatar_Material material;
    avatar_LightLookParams lightLookParams;
    avatar_SkinLookParams skinLookParams;
    int lightsCount;
    avatar_Light lights[10];
    int lightMask;
    float eyeGlintExponential;
    float eyeGlintIntensity;
    float3 ambient_color;
    float ambient_occlusion;
    int debugMode;
};

struct avatar_FragmentOutput
{
    float4 color;
    float3 p_specular;
    float3 p_diffuse;
    float3 a_specular;
    float3 a_diffuse;
    float3 subSurfaceColor;
    float3 preToneMap;
    uint alphaCoverage;
};

struct avatar_SpecularData
{
    float3 directional_light_color;
    float range_attentuation;
    float spot_attenuation;
    float _distance;
    float3 point_to_light;
    float actualCos;
    float3 l;
    float3 h;
    float roughPow2;
    float roughPow4;
    float invRoughPow4;
    float NdotV;
};

struct avatar_HemisphereNormalOffsets
{
    float3 nn;
    float3 bb;
    float3 tt;
    float3 lv1;
    float3 lv2;
    float3 lv3;
};



uniform sampler2D u_BaseColorSampler;
uniform sampler2D u_MetallicRoughnessSampler;
uniform sampler2D u_NormalSampler;
uniform samplerCUBE _ReflectionCubeMap;
uniform float u_NormalScale;
uniform float4 u_BaseColorFactor;
uniform int u_MipCount;
uniform int Debug;
uniform float u_Exposure;
uniform float u_MetallicFactor;
uniform float u_OcclusionStrength;
uniform float u_RoughnessFactor;
uniform float u_ThicknessFactor;
uniform float3 u_SubsurfaceColor;
uniform float3 u_SkinORMFactor;
uniform float u_EyeGlintFactor;
uniform float u_EyeGlintColorFactor;
uniform float3 u_HairSubsurfaceColor;
uniform float u_HairScatterIntensity;
uniform float3 u_HairSpecularColorFactor;
uniform float u_HairSpecularShiftIntensity;
uniform float u_HairSpecularWhiteIntensity;
uniform float u_HairSpecularColorIntensity;
uniform float u_HairSpecularColorOffset;
uniform float u_HairRoughness;
uniform float u_HairColorRoughness;
uniform float u_HairAnisotropicIntensity;
uniform float u_HairSpecularNormalIntensity;
uniform float u_HairDiffusedIntensity;
uniform float u_HairSpecularGlint;
uniform float3 u_FacialHairSubsurfaceColor;
uniform float u_FacialHairScatterIntensity;
uniform float3 u_FacialHairSpecularColorFactor;
uniform float u_FacialHairSpecularShiftIntensity;
uniform float u_FacialHairSpecularWhiteIntensity;
uniform float u_FacialHairSpecularColorIntensity;
uniform float u_FacialHairSpecularColorOffset;
uniform float u_FacialHairRoughness;
uniform float u_FacialHairColorRoughness;
uniform float u_FacialHairAnisotropicIntensity;
uniform float u_FacialHairSpecularNormalIntensity;
uniform float u_FacialHairDiffusedIntensity;
uniform float u_FacialHairSpecularGlint;
uniform float u_RimLightIntensity;
uniform float u_RimLightBias;
uniform float3 u_RimLightColor;
uniform float u_RimLightTransition;
uniform float u_RimLightStartPosition;
uniform float u_RimLightEndPosition;
uniform sampler2D u_ColorGradientSampler;
uniform int u_RampSelector;

static float4 _21;



struct FragmentOutput
{
    float4 _21 : COLOR0;
};


avatar_FragOptions avatar_zeroOptions()
{
    avatar_FragOptions options;
    options.hasBaseColorMap = false;
    options.hasMetallicRoughnessMap = false;
    options.useIBLRotation = false;
    options.enableNormalMapping = false;
    options.enableAlphaToCoverage = false;
    options.enableEnvironmentMap = false;
    options.enableRimLight = false;
    options.enablePreviewColorRamp = false;
    options.enableDebugRender = false;
    options.enableSkin = false;
    options.enableEyeGlint = false;
    options.enableHeadHair = false;
    options.enableFacialHair = false;
    options.enableAnyHair = false;
    options.enableShadows = false;
    options.enableLightMask = false;
    return options;
}

avatar_Matrices avatar_zeroMatrices()
{
    avatar_Matrices matrices;
    matrices.objectToWorld = float4x4(0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx);
    matrices.worldToObject = float3x3(0.0f.xxx, 0.0f.xxx, 0.0f.xxx);
    matrices.viewProjection = float4x4(0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx);
    matrices.environmentRotation = float3x3(float3(1.0f, 0.0f, 0.0f), float3(0.0f, 1.0f, 0.0f), float3(0.0f, 0.0f, 1.0f));
    return matrices;
}

avatar_Geometry avatar_zeroGeometry()
{
    avatar_Geometry geometry;
    geometry.camera = 0.0f.xxx;
    geometry.positionInWorldSpace = 0.0f.xxx;
    geometry.positionInClipSpace = 0.0f.xxx;
    geometry.normal = 0.0f.xxx;
    geometry.normalMap = 0.0f.xxx;
    geometry.tangentSpace.normal = 0.0f.xxx;
    geometry.tangentSpace.tangent = 0.0f.xxx;
    geometry.tangentSpace.bitangent = 0.0f.xxx;
    geometry.texcoord_0 = 0.0f.xx;
    geometry.texcoord_1 = 0.0f.xx;
    geometry.color = 0.0f.xxxx;
    geometry.ormt = 0.0f.xxxx;
    geometry.normalScale = 0.0f;
    geometry.invertNormalSpaceEyes = false;
    geometry.worldViewDir = 0.0f.xxx;
    geometry.lod = 0.0f;
    return geometry;
}

avatar_SkinMaterial avatar_zeroSkinMaterial()
{
    avatar_SkinMaterial material;
    material.subsurface_color = 0.0f.xxx;
    material.skin_ORM_factor = 0.0f.xxx;
    return material;
}

avatar_HairMaterial avatar_zeroHairMaterial()
{
    avatar_HairMaterial material0;
    material0.subsurface_color = 0.0f.xxx;
    material0.scatter_intensity = 0.0f;
    material0.specular_color_factor = 0.0f.xxx;
    material0.specular_shift_intensity = 0.0f;
    material0.specular_white_intensity = 0.0f;
    material0.specular_white_roughness = 0.0f;
    material0.specular_color_intensity = 0.0f;
    material0.specular_color_offset = 0.0f;
    material0.specular_color_roughness = 0.0f;
    material0.anisotropic_intensity = 0.0f;
    material0.diffused_intensity = 0.0f;
    material0.normal_intensity = 0.0f;
    material0.specular_glint = 0.0f;
    material0.ao_intensity = 0.0f;
    material0.flow_sample = 0.0f;
    material0.flow_angle = 0.0f;
    material0.shift = 0.0f;
    material0.blend = 0.0f;
    material0.aniso_blend = 0.0f;
    return material0;
}

avatar_RimLightMaterial avatar_zeroRimLightMaterial()
{
    avatar_RimLightMaterial material1;
    material1.intensity = 0.0f;
    material1.bias = 0.0f;
    material1.color = 0.0f.xxx;
    material1.transition = 0.0f;
    material1.start = 0.0f;
    material1.end = 0.0f;
    return material1;
}

avatar_Material avatar_zeroMaterial()
{
    avatar_Material material2;
    material2.base_color = 0.0f.xxx;
    material2.alpha = 0.0f;
    material2.exposure = 0.0f;
    material2.metallic = 0.0f;
    material2.occlusion = 0.0f;
    material2.roughness = 0.0f;
    material2.thickness = 0.0f;
    material2.ambient_diffuse_factor = 1.0f;
    material2.ambient_specular_factor = 1.0f;
    material2.eye_glint_factor = 0.0f;
    material2.eye_glint_color_factor = 0.0f;
    material2.skin_material = avatar_zeroSkinMaterial();
    material2.hair_material = avatar_zeroHairMaterial();
    material2.rim_light_material = avatar_zeroRimLightMaterial();
    material2.ramp_selector = 0.0f;
    material2.color_selector_lod = 0;
    material2.SSSWrapAngle = 0.0f;
    material2.diffuseWrapAngle = 0.0f;
    material2.f0 = 0.0f;
    material2.f90 = 0.0f;
    return material2;
}

avatar_LightLookParams avatar_zeroLightLookParams()
{
    avatar_LightLookParams lightLookParams;
    lightLookParams.lightSampleCount = 0;
    lightLookParams.lightSize = 0.0f;
    lightLookParams.roughnessCutOff = 0.0f;
    lightLookParams.lowerBound = 0.0f;
    lightLookParams.reduceRoughnessByValue = 0.0f;
    lightLookParams.reducedLightSizeMultiplier = 0.0f;
    lightLookParams.multiSampleBrightnessMultiplier = 0.0f;
    lightLookParams.singleSampleBrightnessMultiplier = 0.0f;
    return lightLookParams;
}

avatar_SkinLookParams avatar_zeroSkinLookParams()
{
    avatar_SkinLookParams skinLookParams;
    skinLookParams.SSSIBLMultiplier = 0.0f;
    skinLookParams.increaseOcclusion = 0.0f;
    return skinLookParams;
}

avatar_Light avatar_zeroLight()
{
    avatar_Light light;
    light.direction = 0.0f.xxx;
    light.range = 0.0f;
    light.color = 0.0f.xxx;
    light.intensity = 0.0f;
    light.position = 0.0f.xxx;
    light.innerConeCos = 0.0f;
    light.outerConeCos = 0.0f;
    light.shadowTerm = 1.0f;
    light.type = 0;
    light.eyeGlint = 0;
    return light;
}

avatar_FragmentInput avatar_zeroFragmentInput(int MAX_LIGHT_COUNT)
{
    avatar_FragmentInput i;
    i.options = avatar_zeroOptions();
    i.matrices = avatar_zeroMatrices();
    i.geometry = avatar_zeroGeometry();
    i.material = avatar_zeroMaterial();
    i.lightLookParams = avatar_zeroLightLookParams();
    i.skinLookParams = avatar_zeroSkinLookParams();
    i.lightsCount = 1;
    for (int idx = 0; idx < MAX_LIGHT_COUNT; idx++)
    {
        i.lights[idx] = avatar_zeroLight();
    }
    i.lightMask = 0;
    i.eyeGlintExponential = 0.0f;
    i.eyeGlintIntensity = 0.0f;
    i.ambient_color = 0.0f.xxx;
    i.ambient_occlusion = 1.0f;
    i.debugMode = 0;
    return i;
}

void setShaderParams(inout avatar_FragmentInput i)
{
    i.lightLookParams.lightSampleCount = lightSampleCount;
    i.lightLookParams.lightSize = lightSize;
    i.lightLookParams.roughnessCutOff = roughnessCutOff;
    i.lightLookParams.lowerBound = lowerBound;
    i.lightLookParams.reduceRoughnessByValue = reduceRoughnessByValue;
    i.lightLookParams.reducedLightSizeMultiplier = reducedLightSizeMultiplier;
    i.lightLookParams.multiSampleBrightnessMultiplier = multiSampleBrightnessMultiplier;
    i.lightLookParams.singleSampleBrightnessMultiplier = singleSampleBrightnessMultiplier;
    i.skinLookParams.SSSIBLMultiplier = SSSIBLMultiplier;
    i.skinLookParams.increaseOcclusion = increaseOcclusion;
    i.material.SSSWrapAngle = SSSWrapAngle;
    i.material.diffuseWrapAngle = diffuseWrapAngle;
    i.material.f0 = f0;
    i.material.f90 = f90;
}

bool material_WithinRange(float idChannel, float lowBound, float highBound)
{
    return (idChannel > (lowBound - 0.001953125f)) && (idChannel < (highBound + 0.001953125f));
}

bool material_IsOfType(float idChannel, float subMeshType)
{
    return material_WithinRange(idChannel, subMeshType, subMeshType);
}

bool material_UseSkin(float idChannel)
{
    return material_IsOfType(idChannel, 0.011764706112444400787353515625f);
}

bool material_UseEyeGlint(float idChannel)
{
    return material_IsOfType(idChannel, 0.007843137718737125396728515625f);
}

bool material_UseHeadHair(float idChannel)
{
    return material_IsOfType(idChannel, 0.01568627543747425079345703125f);
}

bool material_UseFacialHair(float idChannel)
{
    return material_IsOfType(idChannel, 0.01960784383118152618408203125f);
}

avatar_FragOptions getFragOptions(float materialTypeChannel)
{
    avatar_FragOptions options = avatar_zeroOptions();
    options.enableNormalMapping = enableNormalMapping;
    options.enableAlphaToCoverage = enableAlphaToCoverage;
    options.enableEnvironmentMap = enableEnvironmentMap;
    options.enableRimLight = enableRimLight;
    if (true)
    {
        options.enableSkin = enableSkin && material_UseSkin(materialTypeChannel);
        options.enableEyeGlint = enableEyeGlint && material_UseEyeGlint(materialTypeChannel);
        options.enableHeadHair = enableHair && material_UseHeadHair(materialTypeChannel);
        options.enableFacialHair = enableHair && material_UseFacialHair(materialTypeChannel);
        options.enableAnyHair = options.enableHeadHair || options.enableFacialHair;
    }
    else
    {
        options.enableSkin = enableSkin;
        options.enableEyeGlint = enableEyeGlint;
        options.enableHeadHair = enableHair;
        options.enableFacialHair = enableHair;
        options.enableAnyHair = enableHair;
    }
    options.enablePreviewColorRamp = enablePreviewColorRamp;
    options.enableDebugRender = enableDebugRender;
    options.hasBaseColorMap = hasBaseColorMap;
    options.hasMetallicRoughnessMap = hasMetallicRoughnessMap;
    return options;
}

float3 calculateBitangent(avatar_TangentSpace tangentSpace)
{
    return normalize(cross(tangentSpace.normal, tangentSpace.tangent));
}

float3 avatar_perturbNormal(avatar_FragmentInput i, float3 normalMapSample)
{
    return mul(normalize(normalMapSample * float3(i.geometry.normalScale, i.geometry.normalScale, 1.0f)), float3x3(i.geometry.tangentSpace.tangent, i.geometry.tangentSpace.bitangent, i.geometry.tangentSpace.normal));
}

float LINEARtoSRGB(float color)
{
    return pow(color, 0.4545454680919647216796875f);
}

float3 computeViewDir(float3 camera, float3 position)
{
    return normalize(position - camera);
}

void AppSpecificPreManipulation(inout avatar_FragmentInput i);

avatar_FragmentOutput avatar_zeroFragmentOutput()
{
    avatar_FragmentOutput o;
    o.color = 0.0f.xxxx;
    o.p_specular = 0.0f.xxx;
    o.p_diffuse = 0.0f.xxx;
    o.a_specular = 0.0f.xxx;
    o.a_diffuse = 0.0f.xxx;
    o.subSurfaceColor = 0.0f.xxx;
    o.preToneMap = 0.0f.xxx;
    o.alphaCoverage = 255u;
    return o;
}

float saturate(float x)
{
    return clamp(x, 0.0f, 1.0f);
}

float computeNdotV(float3 normal, float3 world_view_dir)
{
    return saturate(-dot(normal, world_view_dir));
}

avatar_SpecularData avatar_fillInSpecularData(float3 normal, float3 worldViewDir, avatar_Light light, float3 lightDirection, float roughness, float exposure, avatar_FragOptions options)
{
    avatar_SpecularData sd;
    sd.directional_light_color = ((light.color * (1.0f / exposure)) * 0.3183098733425140380859375f) * light.intensity;
    sd.point_to_light = -lightDirection;
    sd.range_attentuation = 0.0f;
    sd.spot_attenuation = 0.0f;
    sd._distance = length(sd.point_to_light);
    sd.l = normalize(sd.point_to_light);
    sd.h = normalize(sd.l - worldViewDir);
    sd.roughPow2 = roughness * roughness;
    sd.roughPow4 = sd.roughPow2 * sd.roughPow2;
    sd.invRoughPow4 = 1.0f - sd.roughPow4;
    sd.NdotV = computeNdotV(normal, worldViewDir);
    return sd;
}

float3 avatar_computeSpecular(float3 normal, float3 worldViewDir, avatar_Light light, float3 lightDirection, avatar_LightLookParams lightLookParams, float roughness, float exposure, avatar_FragOptions options)
{
    avatar_SpecularData sd = avatar_fillInSpecularData(normal, worldViewDir, light, lightDirection, roughness, exposure, options);
    float NdotL_1 = saturate(dot(normal, sd.l));
    float NdotL = NdotL_1;
    float NdotH_1 = saturate(dot(normal, sd.h));
    float NdotH = NdotH_1;
    if (options.enableSkin || options.enableAnyHair)
    {
        NdotL = smoothstep(0.0f, 1.0f, NdotL_1 + 0.0f);
        NdotH = smoothstep(0.0f, 1.0f, NdotH_1 + 0.0f);
    }
    float _3887 = sd.NdotV;
    float _3892 = sd.invRoughPow4;
    float _3895 = sd.roughPow2;
    float ggx = (NdotL * sqrt(((_3887 * _3887) * _3892) + _3895)) + (_3887 * sqrt(((NdotL * NdotL) * _3892) + _3895));
    float t = 1.0f / (1.0f - ((NdotH * NdotH) * _3892));
    return (((light.color * (1.0f / exposure)) * light.intensity) * ((((NdotL * t) * t) * sd.roughPow4) * ((ggx > 0.0f) ? (0.5f / ggx) : 0.0f))) * lightLookParams.singleSampleBrightnessMultiplier;
}

float3 avatar_computeDiffuse(avatar_Geometry geometry, avatar_Light light, avatar_Material material, out float3 diffuseWrap)
{
    float3 directional_light_color = ((light.color * (1.0f / material.exposure)) * 0.3183098733425140380859375f) * light.intensity;
    float NdotL = dot(geometry.normal, normalize(-light.direction));
    diffuseWrap = directional_light_color * saturate(smoothstep(material.SSSWrapAngle, 1.0f, NdotL));
    return directional_light_color * saturate(smoothstep(material.diffuseWrapAngle, 1.0f, NdotL));
}

float3 avatar_computeSpecular(avatar_Geometry geometry, avatar_Light light, avatar_LightLookParams lightLookParams, avatar_Material material, avatar_FragOptions options)
{
    return avatar_computeSpecular(geometry.normal, geometry.worldViewDir, light, light.direction, lightLookParams, material.roughness, material.exposure, options);
}

bool avatar_eyeGlintCondition(avatar_FragmentInput i, avatar_Light light)
{
    return i.options.enableEyeGlint;
}

float3 reflection(float3 normal, float3 world_view_dir)
{
    return world_view_dir - ((normal * 2.0f) * dot(world_view_dir, normal));
}

float4 mod289(float4 x)
{
    return x - (floor(x * 0.00346020772121846675872802734375f) * 289.0f);
}

float4 perm(float4 x)
{
    return mod289(((x * 34.0f) + 1.0f.xxxx) * x);
}

float _noise(float3 p)
{
    float3 a = floor(p);
    float3 d = p - a;
    float3 d_1 = (d * d) * (3.0f.xxx - (d * 2.0f));
    float4 b = a.xxyy + float4(0.0f, 1.0f, 0.0f, 1.0f);
    float4 c = perm(perm(b.xyxy).xyxy + b.zzww) + a.zzzz;
    float _2441 = d_1.z;
    float4 o3 = (frac(perm(c + 1.0f.xxxx) * 0.024390242993831634521484375f) * _2441) + (frac(perm(c) * 0.024390242993831634521484375f) * (1.0f - _2441));
    float _2453 = d_1.x;
    float2 o4 = (o3.yw * _2453) + (o3.xz * (1.0f - _2453));
    float _2465 = d_1.y;
    return (o4.y * _2465) + (o4.x * (1.0f - _2465));
}

float3 computeSpecularHighlight(float anisotropicIntensity, float roughness, float3 L, float3 E, float3 t, float3 tangent, float3 bitangent, float offset)
{
    float3 H = 0.0f.xxx;
    float kspec = 0.0f;
    float kexp = 0.0f;
    float3 spec = 0.0f.xxx;
    float3 t_1 = normalize(t + (bitangent * offset));
    if (anisotropicIntensity > 0.0f)
    {
        float3 _4117 = E + L;
        float3 isotropicH = normalize(_4117);
        H = normalize(_4117 - (tangent * dot(_4117, tangent)));
        H = normalize(lerp(isotropicH, H, anisotropicIntensity.xxx));
        kspec = dot(H, t_1);
        kexp = 1.0f / ((roughness * roughness) + 0.001000000047497451305389404296875f);
    }
    else
    {
        H = normalize(E + L);
        kspec = dot(t_1, H);
        kexp = 3.0f / ((roughness * roughness) + 0.001000000047497451305389404296875f);
    }
    if (kspec > (-0.001000000047497451305389404296875f))
    {
        float specular = pow(max(0.0f, kspec), kexp);
        spec = 0.0f.xxx + specular.xxx;
    }
    return spec;
}

float3 computeHairSpecular(avatar_FragmentInput i, float3 lightVector, float3x3 hairCoordinateSystem, float anisotropicBlend)
{
    float3 E = -i.geometry.worldViewDir;
    float3 L = normalize(-lightVector);
    float anisotropy = lerp(0.0f, i.material.hair_material.anisotropic_intensity, anisotropicBlend);
    float localOffset = ((i.material.hair_material.specular_shift_intensity * (i.material.hair_material.shift - 0.5f)) * anisotropicBlend) + (((_noise(float3(i.geometry.texcoord_0.x, i.geometry.texcoord_0.y, float2(0.0f, 1.0f).x) * 2000.0f.xxx) * 2.0f) - 1.0f) * 0.00999999977648258209228515625f);
    return ((computeSpecularHighlight(anisotropy, i.material.hair_material.specular_white_roughness, L, E, hairCoordinateSystem[0], hairCoordinateSystem[2], hairCoordinateSystem[1], localOffset) * i.material.hair_material.specular_white_intensity) + ((computeSpecularHighlight(anisotropy, i.material.hair_material.specular_color_roughness, L, E, hairCoordinateSystem[0], hairCoordinateSystem[2], hairCoordinateSystem[1], i.material.hair_material.specular_color_offset + localOffset) * i.material.hair_material.specular_color_factor) * i.material.hair_material.specular_color_intensity)) * i.material.hair_material.ao_intensity;
}

float3 blendPunctualSpecularWithHair(float3 punctualSpec, float3 hairPunctualSpec, float hairBlend)
{
    return lerp(punctualSpec, hairPunctualSpec, hairBlend.xxx);
}

float3 blendSubSurfaceColorWithHair(float3 hairSubsurfaceColor, float3 skinSubsurfaceColor, float hairBlend)
{
    return lerp(hairSubsurfaceColor, skinSubsurfaceColor, hairBlend.xxx);
}

avatar_HemisphereNormalOffsets avatar_computeHemisphereNormalOffsets(avatar_FragmentInput i)
{
    avatar_HemisphereNormalOffsets hno;
    hno.nn = mul(i.matrices.environmentRotation, i.geometry.tangentSpace.normal * 0.707099974155426025390625f);
    hno.tt = mul(i.matrices.environmentRotation, i.geometry.tangentSpace.tangent * 0.3535499870777130126953125f);
    hno.bb = mul(i.matrices.environmentRotation, i.geometry.tangentSpace.bitangent * 0.612348616123199462890625f);
    hno.lv1 = hno.nn + (hno.tt * 2.0f);
    hno.lv2 = (hno.nn + hno.bb) - hno.tt;
    hno.lv3 = (hno.nn - hno.bb) - hno.tt;
    return hno;
}

float3 saturate(float3 v)
{
    return clamp(v, 0.0f.xxx, 1.0f.xxx);
}

float3 avatar_addRimLight(avatar_Geometry geometry, avatar_Material t)
{
    float multiplier = 1.0f;
    avatar_Material t_1 = t;
    float gradient = (atan2(dot(geometry.normal, float3(1.0f, 0.0f, 0.0f)), dot(geometry.normal, float3(0.0f, 1.0f, 0.0f))) / 6.283185482025146484375f) + 0.5f;
    if (gradient < t.rim_light_material.start)
    {
        multiplier = 0.0f;
    }
    if ((gradient >= t.rim_light_material.start) && (gradient <= t.rim_light_material.end))
    {
        multiplier = smoothstep(t.rim_light_material.start, t.rim_light_material.start + t.rim_light_material.transition, gradient);
        multiplier *= smoothstep(t.rim_light_material.end, t.rim_light_material.end - t.rim_light_material.transition, gradient);
    }
    if (gradient > t.rim_light_material.end)
    {
        multiplier = 0.0f;
    }
    if (t.rim_light_material.bias == 0.0f)
    {
        t_1.rim_light_material.bias = 0.001000000047497451305389404296875f;
    }
    return (t_1.rim_light_material.color * t_1.rim_light_material.intensity) * ((pow(clamp(1.0f - computeNdotV(geometry.normal, geometry.worldViewDir), 0.0f, 1.0f), 1.0f / t_1.rim_light_material.bias) * multiplier) * t_1.hair_material.ao_intensity);
}

float dither17b(float2 svPosition, float frameIndexMod4)
{
    return frac(dot(float3(svPosition, frameIndexMod4), float3(0.117647059261798858642578125f, 0.4117647111415863037109375f, 1.35294115543365478515625f)));
}

uint alphaToCoverage(float alpha)
{
    uint Coverage = 0u;
    if (alpha > 0.0f)
    {
        Coverage = 136u;
    }
    if (alpha > 0.25f)
    {
        Coverage = 153u;
    }
    if (alpha > 0.5f)
    {
        Coverage = 221u;
    }
    if (alpha > 0.75f)
    {
        Coverage = 255u;
    }
    return Coverage;
}

uint coverageFromMaskMSAA4(float t, float2 svPos, bool dither)
{
    float t_1 = t;
    if (dither)
    {
        t_1 = t - (dither17b(svPos, 0.0f) / 4.0f);
    }
    else
    {
        t_1 -= 0.125f;
    }
    return alphaToCoverage(t_1);
}

uint avatar_calculateAlphaCoverage(avatar_FragmentInput i, float3 positionInScreenSpace)
{
    bool _return = false;
    uint _returnValue;
    if (!i.options.enableAlphaToCoverage)
    {
        _return = true;
        _returnValue = 255u;
    }
    if (!_return)
    {
        _return = true;
        _returnValue = coverageFromMaskMSAA4(i.material.alpha, positionInScreenSpace.xy, true);
    }
    return _returnValue;
}

void AppSpecificPostManipulation(avatar_FragmentInput i, inout avatar_FragmentOutput o);

float3 SRGBtoLINEAR(float3 srgbIn)
{
    return pow(srgbIn, 2.2000000476837158203125f.xxx);
}

bool submesh_WithinRange(float idChannel, float lowBound, float highBound)
{
    return (idChannel > (lowBound - 0.001953125f)) && (idChannel < (highBound + 0.001953125f));
}

bool submesh_IsOfType(float idChannel, float subMeshType)
{
    return submesh_WithinRange(idChannel, subMeshType, subMeshType);
}

float4 avatar_finalOutputColor(avatar_FragmentInput i, avatar_FragmentOutput o)
{
    float4 color = o.color;
    if (i.debugMode == 1)
    {
        color = float4(i.material.base_color.x, i.material.base_color.y, i.material.base_color.z, float2(0.0f, 1.0f).y);
    }
    if (i.debugMode == 2)
    {
        float3 _4434 = i.material.occlusion.xxx;
        color = float4(_4434.x, _4434.y, _4434.z, color.w);
    }
    if (i.debugMode == 3)
    {
        float3 _4445 = ConvertOutputColorSpaceFromSRGB(i.material.roughness.xxx);
        color = float4(_4445.x, _4445.y, _4445.z, color.w);
        if (i.options.enableAnyHair)
        {
            float3 _4455 = ConvertOutputColorSpaceFromSRGB(i.material.hair_material.flow_sample.xxx);
            color = float4(_4455.x, _4455.y, _4455.z, color.w);
        }
    }
    if (i.debugMode == 4)
    {
        float3 _4466 = ConvertOutputColorSpaceFromSRGB(i.material.metallic.xxx);
        color = float4(_4466.x, _4466.y, _4466.z, color.w);
    }
    if (i.debugMode == 5)
    {
        float3 _4476 = i.material.thickness.xxx;
        color = float4(_4476.x, _4476.y, _4476.z, color.w);
    }
    if (i.debugMode == 6)
    {
        float3 _4487 = (i.geometry.normal * 0.5f) + 0.5f.xxx;
        color = float4(_4487.x, _4487.y, _4487.z, color.w);
    }
    if (i.debugMode == 19)
    {
        float3 _4498 = (i.geometry.tangentSpace.tangent * 0.5f) + 0.5f.xxx;
        color = float4(_4498.x, _4498.y, _4498.z, color.w);
    }
    if (i.debugMode == 20)
    {
        float3 _4509 = (i.geometry.tangentSpace.bitangent * 0.5f) + 0.5f.xxx;
        color = float4(_4509.x, _4509.y, _4509.z, color.w);
    }
    if (i.debugMode == 7)
    {
        color = float4(i.geometry.normalMap.x, i.geometry.normalMap.y, i.geometry.normalMap.z, color.w);
    }
    if (i.debugMode == 8)
    {
    }
    if (i.debugMode == 9)
    {
        float3 world_view_dir = computeViewDir(i.geometry.camera, i.geometry.positionInWorldSpace);
        color = float4(world_view_dir.x, world_view_dir.y, world_view_dir.z, float2(0.0f, 1.0f).y);
    }
    if (i.debugMode == 10)
    {
        float3 _4545 = o.p_specular + o.p_diffuse;
        color = float4(_4545.x, _4545.y, _4545.z, color.w);
    }
    if (i.debugMode == 11)
    {
        color = float4(o.p_specular.x, o.p_specular.y, o.p_specular.z, color.w);
    }
    if (i.debugMode == 12)
    {
        color = float4(o.p_diffuse.x, o.p_diffuse.y, o.p_diffuse.z, color.w);
    }
    if (i.debugMode == 13)
    {
        float3 _4571 = o.a_specular + o.a_diffuse;
        color = float4(_4571.x, _4571.y, _4571.z, color.w);
    }
    if (i.debugMode == 14)
    {
        color = float4(o.a_specular.x, o.a_specular.y, o.a_specular.z, color.w);
    }
    if (i.debugMode == 15)
    {
        color = float4(o.a_diffuse.x, o.a_diffuse.y, o.a_diffuse.z, color.w);
    }
    if (i.debugMode == 16)
    {
        color = float4(o.preToneMap.x, o.preToneMap.y, o.preToneMap.z, color.w);
    }
    if (i.debugMode == 17)
    {
        color = float4(o.subSurfaceColor.x, o.subSurfaceColor.y, o.subSurfaceColor.z, color.w);
    }
    if (i.debugMode == 21)
    {
        float3 _4613 = i.ambient_occlusion.xxx;
        color = float4(_4613.x, _4613.y, _4613.z, color.w);
    }
    if (i.debugMode == 18)
    {
        float subMeshId = i.material.alpha;
        color = float4(0.0f.xxx.x, 0.0f.xxx.y, 0.0f.xxx.z, color.w);
        if (submesh_IsOfType(subMeshId, 0.0039215688593685626983642578125f))
        {
            color = float4(0.20000000298023223876953125f.xxx.x, 0.20000000298023223876953125f.xxx.y, 0.20000000298023223876953125f.xxx.z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.007843137718737125396728515625f))
        {
            color = float4(float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).x, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).y, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.011764706112444400787353515625f))
        {
            color = float4(float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).x, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).y, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.01568627543747425079345703125f))
        {
            color = float4(float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).x, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).y, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.01960784383118152618408203125f))
        {
            color = float4(float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).x, float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).y, float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.02352941222488880157470703125f))
        {
            color = float4(float3(0.0f, 0.0f, 1.0f).x, float3(0.0f, 0.0f, 1.0f).y, float3(0.0f, 0.0f, 1.0f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.02745098061859607696533203125f))
        {
            color = float4(float3(0.0f, 1.0f, 0.0f).x, float3(0.0f, 1.0f, 0.0f).y, float3(0.0f, 1.0f, 0.0f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.0313725508749485015869140625f))
        {
            color = float4(float3(0.5f, 0.0f, 0.0f).x, float3(0.5f, 0.0f, 0.0f).y, float3(0.5f, 0.0f, 0.0f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.0352941192686557769775390625f))
        {
            color = float4(float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).x, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).y, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.0392156876623630523681640625f))
        {
            color = float4(0.100000001490116119384765625f.xxx.x, 0.100000001490116119384765625f.xxx.y, 0.100000001490116119384765625f.xxx.z, color.w);
        }
        if (submesh_IsOfType(subMeshId, 0.0431372560560703277587890625f))
        {
            color = float4(1.0f.xxx.x, 1.0f.xxx.y, 1.0f.xxx.z, color.w);
        }
    }
    if (i.debugMode == 22)
    {
        float materialId = i.material.alpha;
        color = float4(0.20000000298023223876953125f.xxx.x, 0.20000000298023223876953125f.xxx.y, 0.20000000298023223876953125f.xxx.z, color.w);
        if (material_IsOfType(materialId, 0.007843137718737125396728515625f))
        {
            color = float4(0.89999997615814208984375f.xxx.x, 0.89999997615814208984375f.xxx.y, 0.89999997615814208984375f.xxx.z, color.w);
        }
        if (material_IsOfType(materialId, 0.011764706112444400787353515625f))
        {
            color = float4(float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).x, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).y, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).z, color.w);
        }
        if (material_IsOfType(materialId, 0.01568627543747425079345703125f))
        {
            color = float4(float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).x, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).y, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).z, color.w);
        }
        if (material_IsOfType(materialId, 0.01960784383118152618408203125f))
        {
            color = float4(float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).x, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).y, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).z, color.w);
        }
    }
    return color;
}

void frag_Fragment_main()
{
    avatar_FragmentInput i = avatar_zeroFragmentInput(10);
    setShaderParams(i);
    i.options = getFragOptions(v_Color.w);
    i.debugMode = Debug;
    int lightCount = getLightCount();
    i.lightsCount = lightCount;
    i.lights[0].intensity = 1.0f;
    i.lights[0].direction = getLightDirection();
    i.lights[0].color = getLightColor();
    i.lights[0].position = getLightPosition();
    i.lights[0].type = 0;
    i.lights[0].range = 1000.0f;
    i.lights[0].innerConeCos = 0.0f;
    i.lights[0].outerConeCos = 0.0f;
    avatar_Light avatarLight;
    for (int idx = 1; idx < 10; idx++)
    {
        if (idx < lightCount)
        {
            OvrLight ovrLight = getAdditionalLight(idx, v_WorldPos);
            avatarLight.direction = -ovrLight.direction;
            avatarLight.intensity = 1.0f;
            avatarLight.color = ovrLight.color;
            avatarLight.position = ovrLight.direction;
            avatarLight.type = 0;
            avatarLight.range = 100.0f;
            avatarLight.innerConeCos = 0.0f;
            avatarLight.outerConeCos = 0.0f;
            i.lights[idx] = avatarLight;
        }
    }
    i.geometry.camera = _WorldSpaceCameraPos;
    i.geometry.positionInWorldSpace = v_WorldPos;
    i.geometry.positionInClipSpace = v_Vertex.xyz / v_Vertex.w.xxx;
    i.geometry.texcoord_0 = v_UVCoord1;
    i.geometry.texcoord_1 = v_UVCoord2;
    i.geometry.normalScale = u_NormalScale;
    i.geometry.invertNormalSpaceEyes = true;
    i.geometry.tangentSpace.normal = normalize(v_Normal);
    i.geometry.tangentSpace.tangent = normalize(v_Tangent.xyz);
    i.geometry.tangentSpace.bitangent = calculateBitangent(i.geometry.tangentSpace);
    i.geometry.normal = i.geometry.tangentSpace.normal;
    if (i.options.enableNormalMapping)
    {
        float3 normalMapSample_1 = float3(((tex2D(u_NormalSampler, i.geometry.texcoord_0) * 2.0f) - 1.0f.xxxx).xy, 1.0f);
        if (i.geometry.invertNormalSpaceEyes && i.options.enableEyeGlint)
        {
            normalMapSample_1.y = (-1.0f) * normalMapSample_1.y;
        }
        float3 normalMapSample = normalMapSample_1;
        i.geometry.normalMap = normalMapSample;
        i.geometry.normal = avatar_perturbNormal(i, normalMapSample);
    }
    i.geometry.color = v_Color;
    i.geometry.ormt = v_ORMT;
    i.material.base_color = StaticSelectMaterialModeColor(u_BaseColorSampler, i.geometry.texcoord_0, float4(i.geometry.color.x, i.geometry.color.y, i.geometry.color.z, float2(0.0f, 1.0f).y)).xyz * u_BaseColorFactor.xyz;
    i.material.ramp_selector = 1.0f - (float(u_RampSelector) / 45.0f);
    i.material.color_selector_lod = 0;
    bool _return = false;
    float3 _returnValue;
    if (i.options.enablePreviewColorRamp)
    {
        float2 rampCoord = float2(LINEARtoSRGB(i.material.base_color.x), i.material.ramp_selector);
        _return = true;
        _returnValue = tex2Dlod(u_ColorGradientSampler, float4(rampCoord, 0.0, float(i.material.color_selector_lod))).xyz;
    }
    if (!_return)
    {
        _return = true;
        _returnValue = i.material.base_color;
    }
    i.material.base_color = _returnValue;
    i.material.alpha = i.geometry.color.w;
    float4 ormt = StaticSelectMaterialModeColor(u_MetallicRoughnessSampler, i.geometry.texcoord_0, i.geometry.ormt);
    float _5390 = ormt.x;
    i.material.occlusion = lerp(1.0f, _5390, u_OcclusionStrength);
    i.material.roughness = ormt.y * u_RoughnessFactor;
    float _5400 = ormt.z;
    i.material.metallic = _5400 * u_MetallicFactor;
    i.material.f0 = 0.039999999105930328369140625f;
    i.material.f90 = lerp(1.0f, i.material.f0, sqrt(i.material.roughness));
    i.material.ambient_diffuse_factor = 1.0f;
    i.material.ambient_specular_factor = 1.0f;
    i.ambient_color = v_SH;
    float _5417 = ormt.w;
    i.material.thickness = _5417 * u_ThicknessFactor;
    i.material.thickness = u_ThicknessFactor;
    if (i.options.enableSkin)
    {
        i.material.occlusion *= u_SkinORMFactor.x;
        i.material.roughness *= u_SkinORMFactor.y;
        i.material.metallic *= u_SkinORMFactor.z;
    }
    i.material.hair_material.subsurface_color = u_HairSubsurfaceColor;
    i.material.hair_material.scatter_intensity = u_HairScatterIntensity;
    i.material.hair_material.specular_color_factor = u_HairSpecularColorFactor;
    i.material.hair_material.specular_shift_intensity = u_HairSpecularShiftIntensity;
    i.material.hair_material.specular_white_intensity = u_HairSpecularWhiteIntensity;
    i.material.hair_material.specular_white_roughness = u_HairRoughness;
    i.material.hair_material.specular_color_intensity = u_HairSpecularColorIntensity;
    i.material.hair_material.specular_color_offset = u_HairSpecularColorOffset;
    i.material.hair_material.specular_color_roughness = u_HairColorRoughness;
    i.material.hair_material.anisotropic_intensity = u_HairAnisotropicIntensity;
    i.material.hair_material.diffused_intensity = u_HairDiffusedIntensity;
    i.material.hair_material.normal_intensity = u_HairSpecularNormalIntensity;
    i.material.hair_material.specular_glint = u_HairSpecularGlint;
    if (i.options.enableFacialHair)
    {
        i.material.hair_material.subsurface_color = u_FacialHairSubsurfaceColor;
        i.material.hair_material.scatter_intensity = u_FacialHairScatterIntensity;
        i.material.hair_material.specular_color_factor = u_FacialHairSpecularColorFactor;
        i.material.hair_material.specular_shift_intensity = u_FacialHairSpecularShiftIntensity;
        i.material.hair_material.specular_white_intensity = u_FacialHairSpecularWhiteIntensity;
        i.material.hair_material.specular_white_roughness = u_FacialHairRoughness;
        i.material.hair_material.specular_color_intensity = u_FacialHairSpecularColorIntensity;
        i.material.hair_material.specular_color_offset = u_FacialHairSpecularColorOffset;
        i.material.hair_material.specular_color_roughness = u_FacialHairColorRoughness;
        i.material.hair_material.anisotropic_intensity = u_FacialHairAnisotropicIntensity;
        i.material.hair_material.diffused_intensity = u_FacialHairDiffusedIntensity;
        i.material.hair_material.normal_intensity = u_FacialHairSpecularNormalIntensity;
        i.material.hair_material.specular_glint = u_FacialHairSpecularGlint;
    }
    i.material.hair_material.ao_intensity = _5390;
    i.material.hair_material.flow_sample = v_ORMT.y;
    i.material.hair_material.flow_angle = ((1.0f - v_ORMT.y) - 0.25f) * 6.283185482025146484375f;
    i.material.hair_material.shift = _5400;
    i.material.hair_material.blend = clamp(_5417 * 2.0f, 0.0f, 1.0f);
    i.material.hair_material.aniso_blend = clamp((_5417 - 0.5f) * 2.0f, 0.0f, 1.0f);
    if (i.options.enableAnyHair)
    {
        i.material.roughness = 0.40045166015625f;
        i.material.metallic = 0.0f;
        i.material.occlusion = 1.0f;
        i.geometry.normal = lerp(i.geometry.tangentSpace.normal, i.geometry.normal, i.material.hair_material.blend.xxx);
        i.material.hair_material.subsurface_color = lerp(float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f), i.material.hair_material.subsurface_color, i.material.hair_material.blend.xxx);
    }
    i.material.rim_light_material.intensity = u_RimLightIntensity;
    i.material.rim_light_material.bias = u_RimLightBias;
    i.material.rim_light_material.color = u_RimLightColor;
    i.material.rim_light_material.transition = u_RimLightTransition;
    i.material.rim_light_material.start = u_RimLightStartPosition;
    i.material.rim_light_material.end = u_RimLightEndPosition;
    i.material.exposure = u_Exposure;
    i.material.skin_material.subsurface_color = u_SubsurfaceColor;
    i.material.skin_material.skin_ORM_factor = u_SkinORMFactor;
    i.material.eye_glint_factor = u_EyeGlintFactor;
    i.material.eye_glint_color_factor = u_EyeGlintColorFactor;
    i.matrices.objectToWorld = unity_ObjectToWorld;
    i.matrices.worldToObject = float3x3(unity_WorldToObject[0].xyz, unity_WorldToObject[1].xyz, unity_WorldToObject[2].xyz);
    i.geometry.worldViewDir = computeViewDir(i.geometry.camera, i.geometry.positionInWorldSpace);
    float mipCount = 1.0f * float(u_MipCount);
    i.geometry.lod = clamp(i.material.roughness * mipCount, 0.0f, mipCount);
    AppSpecificPreManipulation(i);
    float3 punctualDiffuseWrap = 0.0f.xxx;
    float3 glintSpecular = 0.0f.xxx;
    float3 glintAmbient = 0.0f.xxx;
    int isEyeGlintLightUsed = 0;
    float3 rimLight = 0.0f.xxx;
    avatar_FragmentOutput o_1 = avatar_zeroFragmentOutput();
    if (i.options.enableEyeGlint)
    {
        avatar_Light glintLight = i.lights[0];
        float3 glintSpecular_1 = avatar_computeSpecular(i.geometry.tangentSpace.normal, i.geometry.worldViewDir, glintLight, i.geometry.worldViewDir, i.lightLookParams, 0.02500000037252902984619140625f * i.material.eye_glint_factor, i.material.exposure, i.options);
        glintSpecular = 0.0f.xxx + glintSpecular_1;
        glintAmbient = 0.0f.xxx + 0.0f.xxx;
        isEyeGlintLightUsed = 1;
    }
    float3 t;
    for (int lightIdx = 0; lightIdx < 10; lightIdx++)
    {
        if (lightIdx < i.lightsCount)
        {
            avatar_Light light = i.lights[lightIdx];
            float3 diffuseWrap = 0.0f.xxx;
            if (light.eyeGlint == 0)
            {
                float3 _5790 = avatar_computeDiffuse(i.geometry, light, i.material, diffuseWrap);
                t = _5790;
            }
            else
            {
                t = 0.0f.xxx;
            }
            float3 diffuseRadiance = t;
            if (i.options.enableShadows)
            {
                diffuseRadiance *= light.shadowTerm;
                diffuseWrap *= light.shadowTerm;
            }
            o_1.p_diffuse += diffuseRadiance;
            punctualDiffuseWrap += diffuseWrap;
            if (i.options.enableLightMask && (((1 << lightIdx) & i.lightMask) == 0))
            {
                continue;
            }
            float3 specular = 0.0f.xxx;
            if (light.eyeGlint < 1)
            {
                specular = avatar_computeSpecular(i.geometry, light, i.lightLookParams, i.material, i.options);
            }
            if (avatar_eyeGlintCondition(i, light))
            {
                specular = specular;
                float3 glintSpecular0 = avatar_computeSpecular(i.geometry.tangentSpace.normal, i.geometry.worldViewDir, light, light.direction, i.lightLookParams, 0.02500000037252902984619140625f * i.material.eye_glint_factor, i.material.exposure, i.options);
                glintSpecular += glintSpecular0;
                isEyeGlintLightUsed = 1;
            }
            if (i.options.enableShadows)
            {
                specular *= light.shadowTerm;
            }
            specular = min(specular, 1000.0f.xxx);
            o_1.p_specular += specular;
        }
    }
    if ((i.options.enableEyeGlint && (!i.options.enableSkin)) && (!i.options.enableAnyHair))
    {
        o_1.p_specular += 0.0f.xxx;
    }
    float _lightProbeGlow;
    float3 sh_4 = vgi_ProbeRadiance(i.geometry.normal, 0.0f, _lightProbeGlow);
    avatar_AmbientLighting ambient;
    ambient.diffuse = sh_4 * i.material.occlusion;
    float3 _6064 = texCUBElod(_ReflectionCubeMap, float4(reflection(i.geometry.normal, i.geometry.worldViewDir), i.geometry.lod));
    ambient.specular = float4(_6064.x, _6064.y, _6064.z, float2(0.0f, 1.0f).x).xyz;
    o_1.a_diffuse = (ambient.diffuse * i.material.ambient_diffuse_factor) * i.ambient_occlusion;
    float hairBlend = 0.0f;
    float3 totalhairPunctualSpec = 0.0f.xxx;
    float fresnelPower = 1.0f - computeNdotV(i.geometry.normal, i.geometry.worldViewDir);
    float f = i.material.f0 + ((i.material.f90 - i.material.f0) * saturate((((fresnelPower * fresnelPower) * fresnelPower) * fresnelPower) * fresnelPower));
    float3 specularFactor = lerp(f.xxx, i.material.base_color, i.material.metallic.xxx) * i.material.occlusion;
    o_1.p_specular *= specularFactor;
    float3 _6135 = ambient.specular * f;
    bool3 _6136 = i.options.enableEyeGlint.xxx;
    o_1.a_specular = float3(_6136.x ? _6135.x : 0.0f.xxx.x, _6136.y ? _6135.y : 0.0f.xxx.y, _6136.z ? _6135.z : 0.0f.xxx.z);
    o_1.a_specular += ((specularFactor * i.material.ambient_specular_factor) * ambient.specular);
    if (i.options.enableAnyHair)
    {
        hairBlend = i.material.hair_material.blend;
        avatar_HairMaterial hair_mat = i.material.hair_material;
        float2 flow = float2(cos(hair_mat.flow_angle), sin(hair_mat.flow_angle));
        float3 hairTangent = (i.geometry.tangentSpace.tangent * flow.x) + (i.geometry.tangentSpace.bitangent * flow.y);
        float3 hairTangent2 = normalize(hairTangent);
        float3 hairNormal = lerp(i.geometry.tangentSpace.normal, i.geometry.normal, i.material.hair_material.normal_intensity.xxx);
        float3x3 hairCoordinateSystem = float3x3(hairNormal, hairTangent2, normalize(cross(hairNormal, hairTangent2)));
        for (int lightIdx_1 = 0; lightIdx_1 < 9; lightIdx_1++)
        {
            if (lightIdx_1 < i.lightsCount)
            {
                avatar_Light light_1 = i.lights[lightIdx_1];
                if (light_1.eyeGlint == 0)
                {
                    float3 directional_light_color = ((light_1.color * (1.0f / i.material.exposure)) * 0.3183098733425140380859375f) * light_1.intensity;
                    totalhairPunctualSpec += ((computeHairSpecular(i, light_1.direction, hairCoordinateSystem, i.material.hair_material.aniso_blend) * directional_light_color) * 0.3183098733425140380859375f);
                }
            }
        }
        o_1.p_specular = blendPunctualSpecularWithHair(o_1.p_specular, totalhairPunctualSpec, hairBlend);
        o_1.subSurfaceColor = blendSubSurfaceColorWithHair(i.material.hair_material.subsurface_color, float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f), hairBlend);
        o_1.a_specular *= (1.0f - hairBlend);
        o_1.p_diffuse *= lerp(1.0f, i.material.hair_material.diffused_intensity, hairBlend);
    }
    avatar_FragmentOutput _5910 = o_1;
    if (i.options.enableSkin || i.options.enableAnyHair)
    {
        o_1.p_diffuse = (punctualDiffuseWrap * float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)) + (_5910.p_diffuse * (1.0f.xxx - float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)));
        float3 subsurfaceColor = 0.0f.xxx;
        float3 diffuse = 0.0f.xxx;
        float3 accumulatedDiffuseColor = 0.0f.xxx;
        avatar_HemisphereNormalOffsets hemisphereNormalOffsets = avatar_computeHemisphereNormalOffsets(i);
        float _lightProbeGlow_1;
        float3 _6442 = vgi_ProbeRadiance(hemisphereNormalOffsets.lv1, 0.0f, _lightProbeGlow_1);
        float3 sh = _6442;
        float3 ibl_diffuse1 = saturate(sh * i.material.occlusion);
        float _lightProbeGlow_2;
        float3 _6450 = vgi_ProbeRadiance(hemisphereNormalOffsets.lv2, 0.0f, _lightProbeGlow_2);
        float3 sh_1 = _6450;
        float3 ibl_diffuse2 = saturate(sh_1 * i.material.occlusion);
        float _lightProbeGlow_3;
        float3 _6458 = vgi_ProbeRadiance(hemisphereNormalOffsets.lv3, 0.0f, _lightProbeGlow_3);
        float3 sh_2 = _6458;
        float3 ibl_diffuse3 = saturate(sh_2 * i.material.occlusion);
        float _lightProbeGlow_4;
        float3 _6466 = vgi_ProbeRadiance(hemisphereNormalOffsets.nn, 0.0f, _lightProbeGlow_4);
        float3 sh_3 = _6466;
        float3 ibl_diffuseN = saturate(sh_3 * i.material.occlusion);
        for (int lightIdx_2 = 0; lightIdx_2 < 9; lightIdx_2++)
        {
            if (lightIdx_2 < i.lightsCount)
            {
                float3 worldSpaceLightDir = -i.lights[lightIdx_2].direction;
                float3 lightColor = (i.lights[lightIdx_2].color * i.lights[lightIdx_2].intensity) * (1.0f / 3.1415927410125732421875f);
                float3 directionalLightColor = lightColor * (1.0f / i.material.exposure);
                float directionalSoftDiffuseValue = (saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv1)) + saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv2))) + saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv3));
                diffuse += (directionalSoftDiffuseValue.xxx * directionalLightColor);
                accumulatedDiffuseColor += (directionalLightColor * saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.nn)));
            }
        }
        float3 softDiffuseLight = (((ibl_diffuse1 + ibl_diffuse2) + ibl_diffuse3) + diffuse) * 0.3333333432674407958984375f;
        subsurfaceColor = ((softDiffuseLight * float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)) * saturate(i.material.occlusion + i.skinLookParams.increaseOcclusion)) + (((accumulatedDiffuseColor + ibl_diffuseN) * (1.0f.xxx - float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f))) * i.material.occlusion);
        o_1.subSurfaceColor = subsurfaceColor;
        o_1.subSurfaceColor -= (o_1.p_diffuse * i.material.occlusion);
        o_1.subSurfaceColor = saturate(o_1.subSurfaceColor);
    }
    o_1.subSurfaceColor *= i.material.base_color;
    avatar_FragmentOutput _5933 = o_1;
    if (i.options.enableRimLight)
    {
        rimLight = 0.0f.xxx + avatar_addRimLight(i.geometry, i.material);
    }
    float3 finalColor_1 = ((((((0.0f.xxx + ((_5933.p_diffuse + _5933.a_diffuse) * (i.material.base_color * (i.material.occlusion * ((true && (isEyeGlintLightUsed > 0)) ? 1.0f : (1.0f - i.material.metallic)))))) + rimLight) + (_5910.p_specular + _5910.a_specular)) + _5933.subSurfaceColor) * i.material.exposure) + glintSpecular) + glintAmbient;
    o_1.preToneMap = finalColor_1;
    o_1.color = float4(finalColor_1.x, finalColor_1.y, finalColor_1.z, o_1.color.w);
    o_1.color.w = 1.0f;
    avatar_FragmentOutput o = o_1;
    o.color = float4(o_1.color.xyz.x, o_1.color.xyz.y, o_1.color.xyz.z, o.color.w);
    o.alphaCoverage = avatar_calculateAlphaCoverage(i, i.geometry.positionInClipSpace);
    AppSpecificPostManipulation(i, o);
    float4 finalColor = float4(o.color.x, o.color.y, o.color.z, float2(0.0f, 1.0f).y);
    if (i.debugMode > 0)
    {
        finalColor = avatar_finalOutputColor(i, o);
    }
    float4 _5532 = finalColor;
    finalColor = float4(_5532.xyz.x, _5532.xyz.y, _5532.xyz.z, _5532.w);
    _21 = float4(_5532.xyz.x, _5532.xyz.y, _5532.xyz.z, _5532.w);
}

FragmentOutput Fragment_main(VertexToFragment stage_input)
{
    v_Vertex = stage_input.v_Vertex;
    v_WorldPos = stage_input.v_WorldPos;
    v_Normal = stage_input.v_Normal;
    v_Tangent = stage_input.v_Tangent;
    v_UVCoord1 = stage_input.v_UVCoord1;
    v_UVCoord2 = stage_input.v_UVCoord2;
    v_Color = stage_input.v_Color;
    v_ORMT = stage_input.v_ORMT;
    v_SH = stage_input.v_SH;
    frag_Fragment_main();
    FragmentOutput stage_output;
    stage_output._21 = float4(_21);
    return stage_output;
}

// Generated by AvatarShaderLibrary 
